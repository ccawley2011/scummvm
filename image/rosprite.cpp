/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

#include "image/rosprite.h"

#include "common/stream.h"
#include "common/substream.h"
#include "common/textconsole.h"
#include "graphics/pixelformat.h"
#include "graphics/surface.h"

namespace Image {

ROSpriteDecoder::ROSpriteDecoder() {
	_surface = 0;
	_palette = 0;
	_paletteColorCount = 0;
	_mask = 0;
}

ROSpriteDecoder::~ROSpriteDecoder() {
	destroy();
}

void ROSpriteDecoder::destroy() {
	if (_surface) {
		_surface->free();
		delete _surface;
		_surface = 0;
	}

	delete[] _palette;
	_palette = 0;
	_paletteColorCount = 0;

	if (_mask) {
		_mask->free();
		delete _mask;
		_mask = 0;
	}

}

bool ROSpriteDecoder::readSpriteType(uint32 spriteType, uint8 &log2BPP, uint8 &xeig, uint8 &yeig) {
	if (spriteType > 0xFF) {
		warning("RISC OS 3.5 sprite mode words are not supported");
		return false;
	}

	if (spriteType > ARRAYSIZE(riscos_mode_vars)) {
		warning("Unrecognised screen mode '%d'", spriteType);
		return false;
	}

	xeig = riscos_mode_vars[spriteType][0];
	yeig = riscos_mode_vars[spriteType][1];
	log2BPP = riscos_mode_vars[spriteType][2];
	return true;
}

bool ROSpriteDecoder::loadStream(Common::SeekableReadStream &stream) {
	destroy();

	/* uint32 size = */ stream.readUint32LE();
	char name[12];
	stream.read(name, 12);
	_width = stream.readUint32LE();
	_height = stream.readUint32LE();
	uint32 firstBit = stream.readUint32LE();
	uint32 lastBit = stream.readUint32LE();
	_spriteOffset = stream.readUint32LE();
	_maskOffset = stream.readUint32LE();
	uint32 spriteType = stream.readUint32LE();

	uint8 log2BPP;
	if (!readSpriteType(spriteType, log2BPP, _xeig, _yeig))
		return false;

	Graphics::PixelFormat format;
	if (log2BPP < 4 && log2BPP > 0) {
		format = Graphics::PixelFormat::createFormatCLUT8();
		_paletteColorCount = 1 << (1 << log2BPP);

		// Read the palette
		_palette = new byte[_paletteColorCount * 3];
		if (_spriteOffset > (uint32)(0x2C + _paletteColorCount * 8)) {
			for (uint16 i = 0; i < _paletteColorCount; i++) {
				stream.readByte();
				_palette[i * 3 + 0] = stream.readByte();
				_palette[i * 3 + 1] = stream.readByte();
				_palette[i * 3 + 2] = stream.readByte();
				stream.readUint32LE();
			}
		} else if (log2BPP == 3) {
			memcpy(_palette, riscos_palette_256, sizeof(riscos_palette_256));
		} else if (log2BPP == 2) {
			memcpy(_palette, riscos_palette_16, sizeof(riscos_palette_16));
		} else if (log2BPP == 1) {
			memcpy(_palette, riscos_palette_4, sizeof(riscos_palette_4));
		} else if (log2BPP == 0) {
			memcpy(_palette, riscos_palette_2, sizeof(riscos_palette_2));
		}
	} else {
		warning("Unsupported Log2BPP value '%d' in sprite '%s'", log2BPP, name);
		return false;
	}

	uint32 realWidth = (_width * 32 + lastBit - firstBit + 1 ) >> log2BPP;
	_surface = new Graphics::Surface();
	_surface->create(realWidth, _height + 1, format);

	switch (log2BPP) {
	case 0:
		convertSprite124(stream, 8, 0x01, 1);
		break;
	case 1:
		convertSprite124(stream, 4, 0x03, 2);
		break;
	case 2:
		convertSprite124(stream, 2, 0x0f, 4);
		break;
	case 3:
		convertSprite8(stream);
		break;
	default:
		return false;
	}

	if (_maskOffset > 0 && _maskOffset != _spriteOffset) {
		_mask = new Graphics::Surface();
		_mask->create(realWidth, _height + 1, Graphics::PixelFormat::createFormatCLUT8());

		switch (log2BPP) {
		case 0:
			convertMask(stream, 8, 0x01, 1);
			break;
		case 1:
			convertMask(stream, 4, 0x03, 2);
			break;
		case 2:
			convertMask(stream, 2, 0x0f, 4);
			break;
		case 3:
			convertMask(stream, 1, 0xff, 8);
			break;
		default:
			break;
		}

	}

	return true;
}

void ROSpriteDecoder::convertMask(Common::SeekableReadStream &stream, const int div, const int mask, const int shift) {
	for (int y = 0; y < _mask->h; y++) {
		stream.seek(_maskOffset + ((_width * 4 + 4) * y));
		byte *dst = (byte *)_mask->getBasePtr(0, y);
		byte color = 0;
		for (int x = 0; x < _mask->w; x++) {
			if (x % div == 0)
				color = stream.readByte();

			*dst++ = (color & mask) ? 0xff : 0;
			color >>= shift;
		}
	}
}

void ROSpriteDecoder::convertSprite124(Common::SeekableReadStream &stream, const int div, const int mask, const int shift) {
	for (int y = 0; y < _surface->h; y++) {
		stream.seek(_spriteOffset + ((_width * 4 + 4) * y));
		byte *dst = (byte *)_surface->getBasePtr(0, y);
		byte color = 0;
		for (int x = 0; x < _surface->w; x++) {
			if (x % div == 0)
				color = stream.readByte();

			*dst++ = (color & mask);
			color >>= shift;
		}
	}
}

void ROSpriteDecoder::convertSprite8(Common::SeekableReadStream &stream) {
	for (int y = 0; y < _surface->h; y++) {
		stream.seek(_spriteOffset + ((_width * 4 + 4) * y));
		byte *dst = (byte *)_surface->getBasePtr(0, y);
		stream.read(dst, _surface->w);
	}
}

bool ROSpriteArea::loadStream(Common::SeekableReadStream &stream, bool isArea) {
	destroy();

	if (isArea) {
		/* uint32 areaSize = */ stream.readUint32LE();
		_headerSize = 16;
	} else {
		_headerSize = 12;
	}

	_count = stream.readUint32LE();
	uint32 nextSprite = stream.readUint32LE() - (16 - _headerSize);
	/* uint32 fileSize = */ stream.readUint32LE() /* - (16 - _headerSize) */;

	if (nextSprite > _headerSize)
		warning("Sprite area contains unhandled extension area");

	for (uint32 i = 0; i < _count; i++) {
		stream.seek(nextSprite);
		uint32 size = stream.readUint32LE();
		char name[12];
		stream.read(name, 12);

		Common::SeekableSubReadStream subStream(&stream, nextSprite, nextSprite + size);
		ROSpriteDecoder *sprite = new ROSpriteDecoder();
		if (!sprite->loadStream(subStream)) {
			delete sprite;
			return false;
		}

		_names.push_back(name);
		_map[name] = sprite;
		nextSprite += size;
	}

	return true;
}

const int riscos_mode_vars[50][3] = {
	{ 1, 2, 0 }, // 0
	{ 2, 2, 1 }, // 1
	{ 3, 2, 2 }, // 2
	{ 1, 2, 1 }, // 3
	{ 2, 2, 0 }, // 4
	{ 3, 2, 1 }, // 5
	{ 2, 2, 1 }, // 6
	{ 2, 2, 2 }, // 7
	{ 1, 2, 1 }, // 8
	{ 2, 2, 2 }, // 9
	{ 3, 2, 3 }, // 10
	{ 1, 2, 1 }, // 11
	{ 1, 2, 2 }, // 12
	{ 2, 2, 3 }, // 13
	{ 1, 2, 2 }, // 14
	{ 1, 2, 3 }, // 15
	{ 1, 2, 2 }, // 16
	{ 1, 2, 2 }, // 17
	{ 1, 1, 0 }, // 18
	{ 1, 1, 1 }, // 19
	{ 1, 1, 2 }, // 20
	{ 1, 1, 3 }, // 21
	{ 0, 1, 2 }, // 22
	{ 1, 1, 0 }, // 23
	{ 1, 2, 3 }, // 24
	{ 1, 1, 0 }, // 25
	{ 1, 1, 1 }, // 26
	{ 1, 1, 2 }, // 27
	{ 1, 1, 3 }, // 28
	{ 1, 1, 0 }, // 29
	{ 1, 1, 1 }, // 30
	{ 1, 1, 2 }, // 31
	{ 1, 1, 3 }, // 32
	{ 1, 2, 0 }, // 33
	{ 1, 2, 1 }, // 34
	{ 1, 2, 2 }, // 35
	{ 1, 2, 3 }, // 36
	{ 1, 2, 0 }, // 37
	{ 1, 2, 1 }, // 38
	{ 1, 2, 2 }, // 39
	{ 1, 2, 3 }, // 40
	{ 1, 2, 0 }, // 41
	{ 1, 2, 1 }, // 42
	{ 1, 2, 2 }, // 43
	{ 1, 2, 0 }, // 44
	{ 1, 2, 1 }, // 45
	{ 1, 2, 2 }, // 46
	{ 2, 2, 3 }, // 47
	{ 2, 1, 2 }, // 48
	{ 2, 1, 3 }  // 49
};

const byte riscos_palette_2[2 * 3] = {
	0xFF, 0xFF, 0xFF, // 0
	0x00, 0x00, 0x00, // 1
};

const byte riscos_palette_4[4 * 3] = {
	0xFF, 0xFF, 0xFF, // 0
	0xBB, 0xBB, 0xBB, // 1
	0x55, 0x55, 0x55, // 2
	0x00, 0x00, 0x00, // 3
};

const byte riscos_palette_16[16 * 3] = {
	0xFF, 0xFF, 0xFF, // 0
	0xDD, 0xDD, 0xDD, // 1
	0xBB, 0xBB, 0xBB, // 2
	0x99, 0x99, 0x99, // 3
	0x77, 0x77, 0x77, // 4
	0x55, 0x55, 0x55, // 5
	0x33, 0x33, 0x33, // 6
	0x00, 0x00, 0x00, // 7
	0x00, 0x44, 0x99, // 8
	0xEE, 0xEE, 0x00, // 9
	0x00, 0xCC, 0x00, // 10
	0xDD, 0x00, 0x00, // 11
	0xEE, 0xEE, 0xBB, // 12
	0x55, 0x88, 0x00, // 13
	0xFF, 0xBB, 0x00, // 14
	0x00, 0xBB, 0xFF, // 15
};

const byte riscos_palette_256[256 * 3] = {
	0x00, 0x00, 0x00, // 0
	0x11, 0x11, 0x11, // 1
	0x22, 0x22, 0x22, // 2
	0x33, 0x33, 0x33, // 3
	0x44, 0x00, 0x00, // 4
	0x55, 0x11, 0x11, // 5
	0x66, 0x22, 0x22, // 6
	0x77, 0x33, 0x33, // 7
	0x00, 0x00, 0x44, // 8
	0x11, 0x11, 0x55, // 9
	0x22, 0x22, 0x66, // 10
	0x33, 0x33, 0x77, // 11
	0x44, 0x00, 0x44, // 12
	0x55, 0x11, 0x55, // 13
	0x66, 0x22, 0x66, // 14
	0x77, 0x33, 0x77, // 15
	0x88, 0x00, 0x00, // 16
	0x99, 0x11, 0x11, // 17
	0xAA, 0x22, 0x22, // 18
	0xBB, 0x33, 0x33, // 19
	0xCC, 0x00, 0x00, // 20
	0xDD, 0x11, 0x11, // 21
	0xEE, 0x22, 0x22, // 22
	0xFF, 0x33, 0x33, // 23
	0x88, 0x00, 0x44, // 24
	0x99, 0x11, 0x55, // 25
	0xAA, 0x22, 0x66, // 26
	0xBB, 0x33, 0x77, // 27
	0xCC, 0x00, 0x44, // 28
	0xDD, 0x11, 0x55, // 29
	0xEE, 0x22, 0x66, // 30
	0xFF, 0x33, 0x77, // 31
	0x00, 0x44, 0x00, // 32
	0x11, 0x55, 0x11, // 33
	0x22, 0x66, 0x22, // 34
	0x33, 0x77, 0x33, // 35
	0x44, 0x44, 0x00, // 36
	0x55, 0x55, 0x11, // 37
	0x66, 0x66, 0x22, // 38
	0x77, 0x77, 0x33, // 39
	0x00, 0x44, 0x44, // 40
	0x11, 0x55, 0x55, // 41
	0x22, 0x66, 0x66, // 42
	0x33, 0x77, 0x77, // 43
	0x44, 0x44, 0x44, // 44
	0x55, 0x55, 0x55, // 45
	0x66, 0x66, 0x66, // 46
	0x77, 0x77, 0x77, // 47
	0x88, 0x44, 0x00, // 48
	0x99, 0x55, 0x11, // 49
	0xAA, 0x66, 0x22, // 50
	0xBB, 0x77, 0x33, // 51
	0xCC, 0x44, 0x00, // 52
	0xDD, 0x55, 0x11, // 53
	0xEE, 0x66, 0x22, // 54
	0xFF, 0x77, 0x33, // 55
	0x88, 0x44, 0x44, // 56
	0x99, 0x55, 0x55, // 57
	0xAA, 0x66, 0x66, // 58
	0xBB, 0x77, 0x77, // 59
	0xCC, 0x44, 0x44, // 60
	0xDD, 0x55, 0x55, // 61
	0xEE, 0x66, 0x66, // 62
	0xFF, 0x77, 0x77, // 63
	0x00, 0x88, 0x00, // 64
	0x11, 0x99, 0x11, // 65
	0x22, 0xAA, 0x22, // 66
	0x33, 0xBB, 0x33, // 67
	0x44, 0x88, 0x00, // 68
	0x55, 0x99, 0x11, // 69
	0x66, 0xAA, 0x22, // 70
	0x77, 0xBB, 0x33, // 71
	0x00, 0x88, 0x44, // 72
	0x11, 0x99, 0x55, // 73
	0x22, 0xAA, 0x66, // 74
	0x33, 0xBB, 0x77, // 75
	0x44, 0x88, 0x44, // 76
	0x55, 0x99, 0x55, // 77
	0x66, 0xAA, 0x66, // 78
	0x77, 0xBB, 0x77, // 79
	0x88, 0x88, 0x00, // 80
	0x99, 0x99, 0x11, // 81
	0xAA, 0xAA, 0x22, // 82
	0xBB, 0xBB, 0x33, // 83
	0xCC, 0x88, 0x00, // 84
	0xDD, 0x99, 0x11, // 85
	0xEE, 0xAA, 0x22, // 86
	0xFF, 0xBB, 0x33, // 87
	0x88, 0x88, 0x44, // 88
	0x99, 0x99, 0x55, // 89
	0xAA, 0xAA, 0x66, // 90
	0xBB, 0xBB, 0x77, // 91
	0xCC, 0x88, 0x44, // 92
	0xDD, 0x99, 0x55, // 93
	0xEE, 0xAA, 0x66, // 94
	0xFF, 0xBB, 0x77, // 95
	0x00, 0xCC, 0x00, // 96
	0x11, 0xDD, 0x11, // 97
	0x22, 0xEE, 0x22, // 98
	0x33, 0xFF, 0x33, // 99
	0x44, 0xCC, 0x00, // 100
	0x55, 0xDD, 0x11, // 101
	0x66, 0xEE, 0x22, // 102
	0x77, 0xFF, 0x33, // 103
	0x00, 0xCC, 0x44, // 104
	0x11, 0xDD, 0x55, // 105
	0x22, 0xEE, 0x66, // 106
	0x33, 0xFF, 0x77, // 107
	0x44, 0xCC, 0x44, // 108
	0x55, 0xDD, 0x55, // 109
	0x66, 0xEE, 0x66, // 110
	0x77, 0xFF, 0x77, // 111
	0x88, 0xCC, 0x00, // 112
	0x99, 0xDD, 0x11, // 113
	0xAA, 0xEE, 0x22, // 114
	0xBB, 0xFF, 0x33, // 115
	0xCC, 0xCC, 0x00, // 116
	0xDD, 0xDD, 0x11, // 117
	0xEE, 0xEE, 0x22, // 118
	0xFF, 0xFF, 0x33, // 119
	0x88, 0xCC, 0x44, // 120
	0x99, 0xDD, 0x55, // 121
	0xAA, 0xEE, 0x66, // 122
	0xBB, 0xFF, 0x77, // 123
	0xCC, 0xCC, 0x44, // 124
	0xDD, 0xDD, 0x55, // 125
	0xEE, 0xEE, 0x66, // 126
	0xFF, 0xFF, 0x77, // 127
	0x00, 0x00, 0x88, // 128
	0x11, 0x11, 0x99, // 129
	0x22, 0x22, 0xAA, // 130
	0x33, 0x33, 0xBB, // 131
	0x44, 0x00, 0x88, // 132
	0x55, 0x11, 0x99, // 133
	0x66, 0x22, 0xAA, // 134
	0x77, 0x33, 0xBB, // 135
	0x00, 0x00, 0xCC, // 136
	0x11, 0x11, 0xDD, // 137
	0x22, 0x22, 0xEE, // 138
	0x33, 0x33, 0xFF, // 139
	0x44, 0x00, 0xCC, // 140
	0x55, 0x11, 0xDD, // 141
	0x66, 0x22, 0xEE, // 142
	0x77, 0x33, 0xFF, // 143
	0x88, 0x00, 0x88, // 144
	0x99, 0x11, 0x99, // 145
	0xAA, 0x22, 0xAA, // 146
	0xBB, 0x33, 0xBB, // 147
	0xCC, 0x00, 0x88, // 148
	0xDD, 0x11, 0x99, // 149
	0xEE, 0x22, 0xAA, // 150
	0xFF, 0x33, 0xBB, // 151
	0x88, 0x00, 0xCC, // 152
	0x99, 0x11, 0xDD, // 153
	0xAA, 0x22, 0xEE, // 154
	0xBB, 0x33, 0xFF, // 155
	0xCC, 0x00, 0xCC, // 156
	0xDD, 0x11, 0xDD, // 157
	0xEE, 0x22, 0xEE, // 158
	0xFF, 0x33, 0xFF, // 159
	0x00, 0x44, 0x88, // 160
	0x11, 0x55, 0x99, // 161
	0x22, 0x66, 0xAA, // 162
	0x33, 0x77, 0xBB, // 163
	0x44, 0x44, 0x88, // 164
	0x55, 0x55, 0x99, // 165
	0x66, 0x66, 0xAA, // 166
	0x77, 0x77, 0xBB, // 167
	0x00, 0x44, 0xCC, // 168
	0x11, 0x55, 0xDD, // 169
	0x22, 0x66, 0xEE, // 170
	0x33, 0x77, 0xFF, // 171
	0x44, 0x44, 0xCC, // 172
	0x55, 0x55, 0xDD, // 173
	0x66, 0x66, 0xEE, // 174
	0x77, 0x77, 0xFF, // 175
	0x88, 0x44, 0x88, // 176
	0x99, 0x55, 0x99, // 177
	0xAA, 0x66, 0xAA, // 178
	0xBB, 0x77, 0xBB, // 179
	0xCC, 0x44, 0x88, // 180
	0xDD, 0x55, 0x99, // 181
	0xEE, 0x66, 0xAA, // 182
	0xFF, 0x77, 0xBB, // 183
	0x88, 0x44, 0xCC, // 184
	0x99, 0x55, 0xDD, // 185
	0xAA, 0x66, 0xEE, // 186
	0xBB, 0x77, 0xFF, // 187
	0xCC, 0x44, 0xCC, // 188
	0xDD, 0x55, 0xDD, // 189
	0xEE, 0x66, 0xEE, // 190
	0xFF, 0x77, 0xFF, // 191
	0x00, 0x88, 0x88, // 192
	0x11, 0x99, 0x99, // 193
	0x22, 0xAA, 0xAA, // 194
	0x33, 0xBB, 0xBB, // 195
	0x44, 0x88, 0x88, // 196
	0x55, 0x99, 0x99, // 197
	0x66, 0xAA, 0xAA, // 198
	0x77, 0xBB, 0xBB, // 199
	0x00, 0x88, 0xCC, // 200
	0x11, 0x99, 0xDD, // 201
	0x22, 0xAA, 0xEE, // 202
	0x33, 0xBB, 0xFF, // 203
	0x44, 0x88, 0xCC, // 204
	0x55, 0x99, 0xDD, // 205
	0x66, 0xAA, 0xEE, // 206
	0x77, 0xBB, 0xFF, // 207
	0x88, 0x88, 0x88, // 208
	0x99, 0x99, 0x99, // 209
	0xAA, 0xAA, 0xAA, // 210
	0xBB, 0xBB, 0xBB, // 211
	0xCC, 0x88, 0x88, // 212
	0xDD, 0x99, 0x99, // 213
	0xEE, 0xAA, 0xAA, // 214
	0xFF, 0xBB, 0xBB, // 215
	0x88, 0x88, 0xCC, // 216
	0x99, 0x99, 0xDD, // 217
	0xAA, 0xAA, 0xEE, // 218
	0xBB, 0xBB, 0xFF, // 219
	0xCC, 0x88, 0xCC, // 220
	0xDD, 0x99, 0xDD, // 221
	0xEE, 0xAA, 0xEE, // 222
	0xFF, 0xBB, 0xFF, // 223
	0x00, 0xCC, 0x88, // 224
	0x11, 0xDD, 0x99, // 225
	0x22, 0xEE, 0xAA, // 226
	0x33, 0xFF, 0xBB, // 227
	0x44, 0xCC, 0x88, // 228
	0x55, 0xDD, 0x99, // 229
	0x66, 0xEE, 0xAA, // 230
	0x77, 0xFF, 0xBB, // 231
	0x00, 0xCC, 0xCC, // 232
	0x11, 0xDD, 0xDD, // 233
	0x22, 0xEE, 0xEE, // 234
	0x33, 0xFF, 0xFF, // 235
	0x44, 0xCC, 0xCC, // 236
	0x55, 0xDD, 0xDD, // 237
	0x66, 0xEE, 0xEE, // 238
	0x77, 0xFF, 0xFF, // 239
	0x88, 0xCC, 0x88, // 240
	0x99, 0xDD, 0x99, // 241
	0xAA, 0xEE, 0xAA, // 242
	0xBB, 0xFF, 0xBB, // 243
	0xCC, 0xCC, 0x88, // 244
	0xDD, 0xDD, 0x99, // 245
	0xEE, 0xEE, 0xAA, // 246
	0xFF, 0xFF, 0xBB, // 247
	0x88, 0xCC, 0xCC, // 248
	0x99, 0xDD, 0xDD, // 249
	0xAA, 0xEE, 0xEE, // 250
	0xBB, 0xFF, 0xFF, // 251
	0xCC, 0xCC, 0xCC, // 252
	0xDD, 0xDD, 0xDD, // 253
	0xEE, 0xEE, 0xEE, // 254
	0xFF, 0xFF, 0xFF  // 255
};

// TODO: This could be generated at runtime instead...
const byte riscos_palette_16_to_256[16] = {
	255, 253, 211, 209,
	47,  45,  3,   0,
	160, 118, 96,  20,
	246, 68,  87,  202
};

} // End of namespace Image
